### 基于异常的错误检测

在对递归下降方法的实现中，我们通过异常的抛出来确定语法错误所在的位置。在每次 match 过程中，若非与期望相匹配，则会抛出所在位置的异常，包括所在行数、期望 token 与实际 token；并对已经加以判断的 token 进行回退（以便下文中的自动推导）。其中异常的 stack trace 便是从语法树根到错误位置的路径。

### 对 Predict 集的自动推导

在传统的递归下降方法中，面对形如

```
A -> B|C|D
```

形式的产生式时，需要手动计算 Predict 集并据此加以判断，预先确定下一步应前进的分支，然后选择并前进。

面对以上形式，我们的做法是，试探性地向每个分支前进，并在每个分支首个终极符未匹配时回退，前往下一个分支进行试探。结合上文错误检测中的异常抛出，我们对于多分支的产生式的处理方式大致如下：

```java
try {
  B;
  return;
} catch (e) {
  // 捕获到异常后，检测该异常是否为第一次match的异常抛出：
  // 若是，则忽略并继续匹配其他分支；
  // 若否，则继续抛出异常，表示此处确实为语法错误。
  if (!e.firstMatch) {
    throw e;
  }
}
try {
  C;
  return;
} catch (e) {
  if (!e.firstMatch) {
    throw e;
  }
}
try {
  D;
  return;
} catch (e) {
  if (!e.firstMatch) {
    throw e;
  }
}

// 若全部分支都检测过，则所有语法都未匹配，直接抛异常
throw new MultiSyntaxException();
```



至于 firstMatch 的处理，在面对形如

```
A -> BCdE
```

形式的产生式时，处理如下

```java
// 对第一个非终极符，不作处理，即其中首次 Match 的异常不会被标记为 false，而其后的异常将递归地在此段落形式的处理下已被标记为 false
B
try {
  // 对此后的语法（无论终极符与非终极符），将 firstMatch 置为 false，因为其相对于 B 来说，已经不是首次匹配
  C;
  match(d);
  E;
} catch (e) {
  e.firstMatch = false;
  throw e;
}
```

而形如

```
A->bCD
```

时，处理方式如下：

```java
// 面对首个终极符的异常，将其 firstMatch 置 true
try {
  match(c);
} catch (e) {
  e.firstMatch = true;
  throw e;
}

// 此处同上
...
```

例外是面对

```
A -> BC|DE
B -> ɛ|F
```

时，若 B 取空分支，则 firstMatch 应递推延续到 C 的首次匹配。否则，若 C 的首次匹配失败，将被误认为并非是首次匹配，从而抛出异常，无法继续检测 DE 分支。对于这种情况的解决办法之一是对匹配次数进行计数，若匹配计数器为0，则还未进行匹配，对此后的首次匹配宽容处理直到第一次匹配后。

但对于题述 SNL 语言的文法，只有一处出现了这种情况，我们对其进行特殊化处理，将以上产生式转化为以下顺序处理：

```
A -> DE|BC
B -> ɛ|F
```

并且 D 的 First 集中不含空。这样 DE 分支将会正常检测，而 First 集为空的分支放在最后，这样即使是首次抛出异常，其后也不存在其他分支，即仍旧出现语法错误可以抛出。这样便简便地解决了这一问题。

值得注意的是，在多个分支的 First 集中都含有空时，这种方法将会失效。